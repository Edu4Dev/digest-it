// // const path = require("path");
// const cloudinary = require("cloudinary").v2;
// const debugMe = require("../utils/debug-me");

// // const integrations = require(contentFolder + "/settings/integrations.json");
// // const env = path.join(__dirname, "../../../../.env");
// // require("dotenv").config({
// //   path: env,
// // });
// // Configuração do Cloudinary

// /**
//  * Uploads a list of image URLs to Cloudinary and returns the URLs of the images stored on Cloudinary.
//  *
//  * @param {Array} gptImgsUrl - Array of URLs for the images generated by GPT.
//  * @param {boolean} debug - Indicates if debug mode is enabled for logging additional information.
//  * @returns {Array} Array of URLs for the images stored on Cloudinary.
//  */
// async function uploadCloudinary(
//   gptImgsUrl,
//   folderName,
//   cloudinaryCloudName,
//   cloudinaryApiKey,
//   cloudinarySecret,
//   debug
// ) {
//   let cloudinaryImgsUrl = [];
//   cloudinary.config({
//     cloud_name: cloudinaryCloudName,
//     api_key: cloudinaryApiKey,
//     api_secret: cloudinarySecret,
//   });
//   // Iiterate over the image URLs, ensuring each upload is processed correctly
//   for (let [index, element] of gptImgsUrl.entries()) {
//     try {
//       // Upload the image to Cloudinary "subfolder/image.ext"
//       const cloudinaryResponse = await cloudinary.uploader.upload(element, {
//         folder: `${folderName || "boilerplate-times"}/ai`, // Sets the destination folder in Cloudinary
//       });

//       debugMe(
//         debug,
//         "Cloudinary Upload Succeed",
//         cloudinaryResponse.secure_url
//       );

//       // Store the image URL in the array, differentiating between the main image and heading images
//       if (index === 0) {
//         cloudinaryImgsUrl.push({
//           mainImg: cloudinaryResponse.secure_url,
//         });
//       } else {
//         cloudinaryImgsUrl.push({
//           headingsImgs: cloudinaryResponse.secure_url,
//         });
//       }
//     } catch (error) {
//       console.log("Cloudinary Upload Fail:", error);
//     }
//   }

//   debugMe(debug, "Cloudinary Images URL", cloudinaryImgsUrl);

//   // Return the URLs of the images stored on Cloudinary
//   return cloudinaryImgsUrl;
// }

// module.exports = uploadCloudinary;
// // const path = require("path");
// const cloudinary = require("cloudinary").v2;
// const debugMe = require("../utils/debug-me");
// const sharp = require('sharp');

// /**
//  * Uploads a list of image URLs to Cloudinary and returns the URLs of the images stored on Cloudinary.
//  *
//  * @param {Array} gptImgsUrl - Array of URLs for the images generated by GPT.
//  * @param {boolean} debug - Indicates if debug mode is enabled for logging additional information.
//  * @returns {Array} Array of URLs for the images stored on Cloudinary.
//  */
// async function uploadCloudinary(
//   gptImgsUrl,
//   folderName,
//   cloudinaryCloudName,
//   cloudinaryApiKey,
//   cloudinarySecret,
//   debug
// ) {
//   let cloudinaryImgsUrl = [];
//   cloudinary.config({
//     cloud_name: cloudinaryCloudName,
//     api_key: cloudinaryApiKey,
//     api_secret: cloudinarySecret,
//   });
//   // Iiterate over the image URLs, ensuring each upload is processed correctly
//   for (let [index, element] of gptImgsUrl.entries()) {
//     try {
//       // Upload the image to Cloudinary "subfolder/image.ext"
//       const cloudinaryResponse = await cloudinary.uploader.upload(element, {
//         folder: `${folderName || "boilerplate-times"}/ai`, // Sets the destination folder in Cloudinary
//       });

//       debugMe(
//         debug,
//         "Cloudinary Upload Succeed",
//         cloudinaryResponse.secure_url
//       );

//       // Store the image URL in the array, differentiating between the main image and heading images
//       if (index === 0) {
//         cloudinaryImgsUrl.push({
//           mainImg: cloudinaryResponse.secure_url,
//         });
//       } else {
//         cloudinaryImgsUrl.push({
//           headingsImgs: cloudinaryResponse.secure_url,
//         });
//       }
//     } catch (error) {
//       console.log("Cloudinary Upload Fail:", error);
//     }
//   }

//   debugMe(debug, "Cloudinary Images URL", cloudinaryImgsUrl);

//   // Return the URLs of the images stored on Cloudinary
//   return cloudinaryImgsUrl;
// }

// module.exports = uploadCloudinary;
const cloudinary = require("cloudinary").v2;
const debugMe = require("../utils/debug-me");
const sharp = require("sharp");
const axios = require("axios");

/**
 * Uploads a list of image URLs to Cloudinary and returns the URLs of the images stored on Cloudinary.
 *
 * @param {Array} gptImgsUrl - Array of URLs for the images generated by GPT.
 * @param {boolean} debug - Indicates if debug mode is enabled for logging additional information.
 * @returns {Array} Array of URLs for the images stored on Cloudinary.
 */
async function uploadCloudinary(
  gptImgsUrl,
  folderName,
  cloudinaryCloudName,
  cloudinaryApiKey,
  cloudinarySecret,
  debug
) {
  let cloudinaryImgsUrl = [];
  cloudinary.config({
    cloud_name: cloudinaryCloudName,
    api_key: cloudinaryApiKey,
    api_secret: cloudinarySecret,
  });

  // Iterate over the image URLs, ensuring each upload is processed correctly
  for (let [index, element] of gptImgsUrl.entries()) {
    try {
      // Fetch the image data
      const response = await axios.get(element, {
        responseType: "arraybuffer",
      });
      const imageBuffer = Buffer.from(response.data, "binary");

      // Process the image with sharp
      const processedImageBuffer = await sharp(imageBuffer)
        .jpeg({ quality: 90 })
        .toBuffer();

      // Upload the processed image to Cloudinary
      const cloudinaryResponse = await new Promise((resolve, reject) => {
        const uploadStream = cloudinary.uploader.upload_stream(
          { folder: `${folderName || "ai-times"}/ai`, format: "jpg" },
          (error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          }
        );

        // Pass the processed buffer to the upload stream
        uploadStream.end(processedImageBuffer);
      });

      debugMe(
        debug,
        "Cloudinary Upload Succeed",
        cloudinaryResponse.secure_url
      );

      // Store the image URL in the array, differentiating between the main image and heading images
      if (index === 0) {
        cloudinaryImgsUrl.push({
          mainImg: cloudinaryResponse.secure_url,
        });
      } else {
        cloudinaryImgsUrl.push({
          headingsImgs: cloudinaryResponse.secure_url,
        });
      }
    } catch (error) {
      console.log("Error processing or uploading image:", error);
    }
  }

  debugMe(debug, "Cloudinary Images URL", cloudinaryImgsUrl);
  // Return the URLs of the images stored on Cloudinary
  return cloudinaryImgsUrl;
}

module.exports = uploadCloudinary;
